{
  "articles/api.html": {
    "href": "articles/api.html",
    "title": "API | aas-transformation-library Documentation",
    "keywords": "API For the end user, there are three relevant classes, all of which extend the DocumentTransformer Class public AssetAdministrationShellEnvironment transform(InputStream inStream, MappingSpecification mapping, Map<String, String> initialVars); This requires three inputs for transformation: A source xml-based document as an InputStream (inStream). A MappingSpecification Object, that holds a parsed json-config file. This can be obtained from the MappingSpecificationParser: new MappingSpecificationParser().loadMappingSpecification(PATH_TO_CONFIG_JSON) Optionally, the user can set the parameters declared by the @parameters section in the config file as a Map<String, String>. If the config does not define such parameters null can be passed which is equivalent to a second transform-method taking only the first two arguments. Depending on what kind of document shall be transformed, different classes should be used: AML files AML files can be transformed by calling the AmlTransformer : AmlTransformer amlTransformer = new AmlTransformer(); shellEnv = amlTransformer.execute(amlInputStream, mapping); AML file validation includes the following steps (cf. AmlValidator.java ): Check that the AML file is a valid XML file Check that the AML file is valid according to the CAEX 3.0 class model AMLX files AMLX contains a AML-file at its core that needs to be unpackaged first AmlxPackage amlxPackage = new AmlxPackageReader().readAmlxPackage(Paths.get(amlxInputFileName).toFile()); InputStream amlInputStream = amlxPackage.getRootAmlFile().getInputStream() After that the tranformation is equivalent to that of an AML-file. AMLX file validation includes the following steps (cf. AmlxValidator.java ): Check whether each document defined in /_rels/.rels exists Check whether each file in the AMLX file (a ZIP archive) is defined in /_rels/.rels Check that the root document exists Check that there is exactly one root document Check that the root document is a valid AML file OPC UA Nodeset files Due to the UANodeSetTransformer inheriting methods from the DocumentTransformer, transforming UA is very similar to AML. UANodeSetTransformer uaTransformer = new UANodeSetTransformer(); shellEnv = uaTransformer.execute(amlInputStream, mapping); The OPC UA Nodeset validation includes the following (cf. UANodeSetSchemaValidator.java ): Check that the nodeset xml file is valid xml file. Check that the nodeset xml file is valid according to UANodeSet.xsd V1.04 schema. Please note : The nodeset EntType.xml is taken from OPC UA information models published by Equinor . Plain XML files Plain XML files can be tranformed using the GenericDocumentTransformer. This transformer does not trigger any validation but also prohibits users from accessing meta-model specific expressions such as @caexAttributeName or @uaChildren ."
  },
  "articles/building.html": {
    "href": "articles/building.html",
    "title": "Importing the AAS Transformation Library | aas-transformation-library Documentation",
    "keywords": "Importing the AAS Transformation Library Local Usage We rely on SapMachine 11 and use Gradle . You can download and build the repository by yourself by following these steps: Clone the GitHub repository: git clone https://github.com/admin-shell-io/aas-transformation-library $ ./gradlew build $ java -jar build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar usage: transform -a <AML_INPUT_FILE> | -amlx <AMLX_INPUT_FILE> | -p -c <CONFIG_FILE> [-P <PLACEHOLDER_VALUES_JSON>] Transform AutomationML file into an AAS structured file -a,--aml <AML_INPUT_FILE> AML input file -amlx,--amlx <AMLX_INPUT_FILE> AMLX input file -c,--config <CONFIG_FILE> Mapping config file -P,--placeholder-values <PLACEHOLDER_VALUES_JSON> Map of placeholder values in JSON format -p,--print-placeholders Print placeholders with description Missing required options: c, [-a AML input file, -amlx AMLX input file, -p Print placeholders with description] $ java -jar ./build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar -c src/test/resources/config/simpleConfig.json -a src/test/resources/aml/full_AutomationComponent.aml [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Loaded config version 1.0.0, aas version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AmlTransformer - Loaded config version 1.0.0, AAS version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AssetAdministrationShellEnvTransformer - Transforming 1 config assets... [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Wrote AAS file to full_AutomationComponent.json $ cd src/test/resources/amlx/minimal_AutomationMLComponent_WithDocuments $ zip -r minimal_AutomationMLComponent_WithDocuments.amlx . -x \"*.DS_Store\" adding: [Content_Types].xml (deflated 52%) adding: _rels/ (stored 0%) adding: _rels/.rels (deflated 68%) adding: lib/ (stored 0%) adding: lib/AutomationComponentLibrary_v1_0_0_Full_CAEX3_BETA.aml (deflated 85%) adding: files/ (stored 0%) adding: files/TestPDFDeviceManual.pdf (deflated 14%) adding: files/TestTXTDeviceManual.txt (stored 0%) adding: files/TestTXTWarranty.txt (stored 0%) adding: CAEX_ClassModel_V.3.0.xsd (deflated 90%) adding: minimal_AutomationMLComponent_WithDocuments.aml (deflated 80%) $ cd ../../../../../ $ java -jar ./build/distributions/aas-transformation-library-shadow-0.0.1-SNAPSHOT.jar -c src/test/resources/config/simpleConfig.json -amlx src/test/resources/amlx/minimal_AutomationMLComponent_WithDocuments/minimal_AutomationMLComponent_WithDocuments.amlx [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Loaded config version 1.0.0, aas version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AmlTransformer - Loaded config version 1.0.0, AAS version 2.0.1 [main] INFO com.sap.dsc.aas.lib.aml.transform.AssetAdministrationShellEnvTransformer - Transforming 1 config assets... [main] INFO com.sap.dsc.aas.lib.aml.ConsoleApplication - Wrote AAS file to minimal_AutomationMLComponent_WithDocuments.json Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestTXTDeviceManual.txt Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestPDFDeviceManual.pdf Writing to: minimal_AutomationMLComponent_WithDocuments/files/TestTXTWarranty.txt Usage as a dependency Currently, builds are exclusively released to GitHub Packages. They can be imported into gradle and maven projects with adjusted versioning, for example: <dependency> <groupId>com.sap.dsc.aas.lib</groupId> <artifactId>aas-transformation-library</artifactId> <version>0.0.1-SNAPSHOT</version> </dependency> Versioning We version using semantic versioning (e.g., 1.0.4 ). The first position indicates the major release. Different major releases canvas contain breaking changes and are not necessarily compliant. The second number indicates the minor release or revision, which contains new features compared to an older revision. The last position is used for hotfixes or bugfixes. Note, that the versioning scheme of this project is not directly aligned with the release process of the metamodel or the java-model library! When revisions of the meta-model are released, the java-model will change and those changes will be integrated in this library eventually."
  },
  "articles/configuration.html": {
    "href": "articles/configuration.html",
    "title": "Configuration | aas-transformation-library Documentation",
    "keywords": "Configuration Asset Administration Shells are instantiated using the basic structure determined in the AAS-JSON specification. However, there are a variety of tools that ease the writing process. Expressions Expressions are bottom-level-objects denoted by a @ at the beginning of the json-key and signify a side-effect during runtime. While those configurations with no expression in their context are just parsed as AAS-JSON, expressions are evaluated with their result determining the structure of the resulting AAS objects. Examples include: @xpath for evaluation of xPath-Queries @caexAttributeName to fetch the attribute name of an element in a AutomationML file. Takes a string. @uaBrowsePath gets a Node's NodeId by its BrowsePath from a OPC UA nodeset file. Takes a list of BrowseNames connected by hierarchical ReferenceTypes. This is called the BrowsePath in OPC UA. @uaChildren takes a BrowsePath (see above) and returns all Nodes that are connected to this node via a hierarchical ReferenceType. Several basic mathematical and boolean operations such as @plus , @times , @max , @negate or @and . Please note that Expressions can only be called from within a @bind - or @foreach -context. Looping with @foreach On every level (except for the aasEnvironmentMapping ) objects can be dynamically generated using this feature. It evaluates the expression and builds objects according to the statements below - once for every returned value. The syntax is as follows: { \"@foreach\": { \"@xpath\": \"someXpath\" }, \"xyz\": \"abc\" } Dynamic evaluation with @bind Looping around the results of an expression would be obsolete if all resulting objects would hold the same values. That's why the @bind Context allows to fill AAS-attributes with the result of an expression. It may only return a single value that will be used. If I wanted to configure changing idShorts based on the iterator, it could look like this: { \"@foreach\": { \"@xpath\": \"someXpathQuery\" }, \"@bind\": { \"idShort\": { \"@xpath\": \"somePotentiallyRelativeXpathQuery\" } } } Pre-defined Expressions with @definitions Usually in the @header (but everywhere else is fine as well), the config can define more complex functions that will then be called using the @def -key in the @bind -context.In the example below, the exampleFunction is called to assign an id to an AAS. { \"@headers\": { \"@definitions\": { \"exampleFunction\": { \"@concatenate\": [ { \"@xpath\": \"someXpath\" }, \"/\", { \"@xpath\": \"someOtherXpath\" } ] } } }, \"aasEnvironmentMapping\": { ..., \"assetAdministrationShells\": { \"identification\": { \"@bind\": { \"id\": { \"@def\": \"exampleFunction\" } } } } } } Structure of the config-json file The configuration file describes how the AAS file should be generated. See this config file for an example. @header The header sets a couple of circumstances for the transformation. aasVersion indicates the version of the meta-model that a given config-file is created for. This matters since the objects and their json-serialization vary greatly with each version. @definitions defines that name and content of the pre-defined expressions (see above) that can later be called with @def @variables allows the user to define values that can be bound to a variable, updated with another @variables statement and dereferenced by @var , each in a @bind -context @namespaces passes namespaces that the DOM4J xPath-Engine needs to successfully evaluate queries on a given XML document. @parameters are fixed value variable that will be replaced after the whole transformation and can be set by the caller during runtime. They are dereferenced by @var as well. Building Asset Administration Shell Environments with the aasEnvironmentMapping The library generates a single AAS Environment for every config-file. The structure of the config-file is as follows. { \"@header\": { \"aasVersion\": \"3.0RC01\", \"@namespaces\": {}, \"@definitions\": {}, \"@variables\": {}, \"@parameters\": {} }, \"aasEnvironmentMapping\": [ { \"assetAdministrationShells\": [], \"assets\": [], \"submodels\": [], \"conceptDescriptions\": [] } ] } This structure looks familiar because everything in the \"aasEnvironmentMapping\" holds the same structure as the JSON- serialization of AAS. This is supported both to reuse the syntax as well as improve maintainability and parsability of the config-JSON files. AssetAdministrationShells { \"@foreach\": { \"@xpath\": \"some-xPath-Query that may return multiple results\" }, \"idShort\": \"someIdShort\", \"identification\": { \"idType\": \"Iri\", \"id\": \"someIri\" }, \"assetInformation\": { ... } } In the above case all AAS would hold the same idShort and identification which is semantically wrong but can be avoided using the @bind operator. Please note that the AAS' submodels: -key holding references to submodel objects is omitted in the config-file since its contents (References to Submodels in the \"submodels\":[] section are generated automatically. Assets Configuring Assets is optional in the transformation library, just like it's optional in the AAS in general. { \"assets\": [ { \"identification\": { \"id\": \"Iri\", \"idType\": \"SomeIri\" } } ] } Submodels An AAS Submodel are generated in the submodels -section and use expressions the same way as explained before. An example: { \"submodels\": [ { \"@foreach\": { \"@xpath\": \"caex:Attribute[@Name='CommercialData']/caex:Attribute[@Name='ManufacturerDetails']\" }, \"semanticId\": { \"keys\": [ { \"value\": \"https://admin-shell.io/zvei/nameplate/1/0/Nameplate\", \"idType\": \"Iri\", \"type\": \"Submodel\" } ] }, \"identification\": { \"id\": \"_submodel1\", \"idType\": \"Custom\" }, \"submodelElements\": [ { \"semanticId\": { \"keys\": [ { \"value\": \"0173-1#02-AAO677#002\", \"idType\": \"Irdi\", \"type\": \"SubmodelElement\" } ] } } ] } ] } SubmodelElements are added into the submodels as defined by the json-spec. Concept Descriptions Concept Descriptions are supported and can be built using the same toolbox of expressions, definitions, variables and control statements like @bind and @foreach."
  },
  "articles/development_workflow.html": {
    "href": "articles/development_workflow.html",
    "title": "Development Workflow | aas-transformation-library Documentation",
    "keywords": "Development Workflow We develop with Github using pull requests (see this Github guide for a short introduction). Development branch. The development branch is always development . Expect changes on this branch from time to time. On push to the development branch, a snapshot release will be triggered. Please ensure the correct naming in the build.gradle file. Releases. The releases mark the development milestones on the main branch with a certain feature completeness. Every push/accepted merge request to the main branch will trigger a release. Pull Requests Feature branches. We develop using the feature branches, see this section of the Git book . We use feature/'feature-name' and bugfix/'bugfix-name' as a naming convention. If you are a member of the development team, create a feature branch directly within the repository. Otherwise, if you are a non-member contributor, fork the repository and create the feature branch in your forked repository. Developers can open pull requests that will be reviewed and merged to the development branch. Branch Prefix. Each PullRequest must contained a list of the changed topics, for instance as a list of bulletpoints. Simply refering to the commit messages is not sufficient. Reviews. Each PullRequest is reviewed by the Maintainers of the project. In order to simplify the workflow, please assign the PullRequest directly to the Maintainer you think is most knowledgable about your changes. Commit Messages The commit messages should follow the guidelines from https://chris.beams.io/posts/git-commit : Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why (instead of how)"
  },
  "index.html": {
    "href": "index.html",
    "title": "Introduction | aas-transformation-library Documentation",
    "keywords": "Introduction The AAS Transformation Library is a software tool that eases the process of creating Asset Administration Shells from other XML-based formats. This functility is critical to integrate existing XML-based industry standard in the AAS, most notably OPC UA Nodeset and AutomationML files (.aml, .amlx). As it builds on open standards, the library is also usable for generic XML-files, however without domain-specific extensions. This library is no competitor to the OPC UA and AutomationML serializations defined in the specification Details of the Asset Administration Shell Pt. 1 as the spec only defines ways to express AAS-native structures in the meta-models of AML or OPC UA. The OPC UA Companion Specification OPC UA for Asset Administration Shell is equivalent to the OPC UA serialization in the spec. This library depends heavily on the implementation of the AAS in java and the corresponding json-deserializer . Scope The AAS strives to provide a generic data model for industrial assets. However, depending on the scope, lifecycle stage and industry, the structure and semantics of a production plants may already be modelled elsewhere. To make use of this knowledge, users require a semi-automatic way to translate other standards to the AAS. This library can help. The library can be used twofold. Users can.. import the library in Java applications to transform models using the most relevant XML-based industrial standards into AAS objects. use the library to build a fat JAR to transform XML files into AAS JSON files locally. It requires two inputs: The first is the file with the source data and the second is a file that tells the transformation engine, how to conduct the mapping. When called from the commandline, the resulting AAS will be serialized to json and written to a file. When used as a dependency in another java-project, it will return an AssetAdministrationShellEnvironment object from the abovementioned java-model library. The user must decide what transformer to use depending on the format of the source file. The project was kicked-off by SAP for AutomationML-transformations and extended its scope from there."
  }
}